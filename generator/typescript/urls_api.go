package typescript

import (
	"fmt"
	"strings"

	"github.com/benoitkugler/gomacro/analysis"
	"github.com/benoitkugler/gomacro/analysis/httpapi"
)

// GenerateURLs generate a TS class exposing URLs for the
// given http API description.
func GenerateURLs(api []httpapi.Endpoint) string {
	// generate the code required for all the endpoints
	typesCode := renderTypes(api)

	urls := make([]string, len(api))
	for i, endpoint := range api {
		urls[i] = generateURL(endpoint)
	}

	return fmt.Sprintf(`
	// Code generated by gomacro/typescript/urls_api.go. DO NOT EDIT

	%s
	
	/** Endpoints exposes the HTTP urls handled by the server. */
	export class Endpoints {
		constructor(private baseURL: string) {}

		%s
	}
	`, typesCode, strings.Join(urls, "\n"))
}

func generateQuery(params []httpapi.TypedParam) (vars, query string) {
	if len(params) == 0 {
		return "", "``"
	}

	var queryChunks []string
	for _, param := range params {
		varName := strings.ReplaceAll(param.Name, "-", "_")
		vars += fmt.Sprintf("%s: %s,", varName, typeName(param.Type)) // quote for names like "id-1"

		insertVariable := varName
		if isBasic, ok := param.Type.(*analysis.Basic); ok && isBasic.Kind() == analysis.BKBool {
			insertVariable = varName + " ? 'YES' : ''"
		}
		queryChunks = append(queryChunks, fmt.Sprintf("%s=${%s}", param.Name, insertVariable))
	}
	query = "`?" + strings.Join(queryChunks, "&") + "`"
	return
}

func generateURL(a httpapi.Endpoint) string {
	params, query := generateQuery(a.Contract.InputQueryParams)
	const template = `
	/** Returns an URL */
 	%[1]s(%[2]s) {
		return %[3]s + %[4]s;
	}
	`
	return fmt.Sprintf(template,
		a.Contract.Name, params, fullUrl(a), query)
}
