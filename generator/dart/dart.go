package dart

import (
	"fmt"
	"sort"
	"strings"

	an "github.com/benoitkugler/gomacro/analysis"
	"github.com/benoitkugler/gomacro/generator"
	gen "github.com/benoitkugler/gomacro/generator"
)

type Output struct {
	Filename string
	Content  []gen.Declaration
}

// Generate converts the given types to their Dart equivalent,
// also adding JSON convertion functions.
// [sourceDirectory] is common root directory shared by all [sources]
// One [Output] is generated by file to write.
func Generate(sourceDirectory string, sources []*an.Analysis) []Output {
	lk := an.NewLinker(sourceDirectory, sources)
	lk.Extension = ".dart"
	// create one list of declaration per output file
	buf := newBuffer(lk)

	for _, an := range sources {
		for _, typ := range an.Source {
			buf.generate(an.Types[typ], buf.linker.GetOutput(typ))
		}
	}

	var out []Output
	for fileName, file := range buf.files {
		// add headers ...
		decls := []generator.Declaration{{
			ID:       "aa_header",
			Content:  "// Code generated by gomacro/generator/dart. DO NOT EDIT\n",
			Priority: true,
		}}
		if lk.IsPredefined(fileName) {
			decls = append(decls, generator.Declaration{
				ID:      "aa_header_json",
				Content: "typedef JSON = Map<String, dynamic>; // alias to shorten JSON convertors",
			})
		}
		// ... and imports
		var imports []string
		for imp := range file.imports {
			if imp != fileName { // do not import itself
				imports = append(imports, fmt.Sprintf("import '%s';", imp))
			}
		}
		sort.Strings(imports)
		decls = append(decls, gen.Declaration{
			ID:       "aa_imports",
			Content:  strings.Join(imports, "\n"),
			Priority: true, // must appear before other decls
		})
		decls = append(decls, file.decls...)

		out = append(out, Output{Filename: fileName, Content: decls})
	}

	return out
}

type buffer struct {
	linker an.Linker
	cache  generator.Cache
	files  map[string]*outFile
}

type outFile struct {
	decls   []generator.Declaration
	imports map[string]bool // the name of the files required by this file
}

func (f *outFile) add(decl generator.Declaration, imports ...string) {
	f.decls = append(f.decls, decl)
	for _, file := range imports {
		f.imports[file] = true
	}
}

func newBuffer(lk an.Linker) buffer {
	out := buffer{
		linker: lk,
		files:  make(map[string]*outFile),
		cache:  make(generator.Cache),
	}
	for _, file := range lk.OutputFiles() {
		out.files[file] = &outFile{imports: make(map[string]bool)}
	}
	return out
}

// Generate converts the given types to their Dart equivalent,
// also adding JSON convertion functions.
// func Generate(an *an.Analysis) []generator.Declaration {
// 	var (
// 		out           []generator.Declaration
// 		generateCache = make(generator.Cache)
// 	)

// 	out = append(out, generator.Declaration{
// 		ID:       "aa_header",
// 		Content:  "// Code generated by gomacro/generator/dart. DO NOT EDIT\n",
// 		Priority: true,
// 	}, generator.Declaration{
// 		ID:      "aa_header_json",
// 		Content: "typedef JSON = Map<String, dynamic>; // alias to shorten JSON convertors",
// 	})

// 	for _, typ := range an.Source {
// 		out = append(out, generate(an.Types[typ], generateCache)...)
// 	}

// 	return out
// }

// generate write the declaation for [typ] (and its children)
// in the proper declaration list, and returns the name of the file updated
func (buf buffer) generate(typ an.Type, parentOutputFile string) string {
	outfile := buf.linker.GetOutput(typ.Type())
	switch typ.(type) {
	case *an.Map, *an.Array:
		// use the parentOutputFile
		outfile = parentOutputFile
	}

	if buf.cache.Check(typ) { // handle recursive types
		return outfile
	}
	file := buf.files[outfile]

	if file == nil {
		panic(fmt.Sprintf("missing output file '%s' (parent :'%s') for type %T", outfile, parentOutputFile, typ))
	}
	switch typ := typ.(type) {
	case *an.Pointer:
		panic("pointers not handled by the Dart generator")
	case *an.Named:
		decl, importS := buf.codeForNamed(typ)
		file.add(decl, importS)
	case *an.Basic:
		file.add(codeForBasic(typ))
	case *an.Time:
		file.add(codeForTime(typ))
	case *an.Array:
		decl, importElem := buf.codeForArray(typ, outfile)
		file.add(decl, importElem)
	case *an.Map:
		decl, importKey, importElem := buf.codeForMap(typ, outfile)
		file.add(decl, importKey, importElem)
	case *an.Extern:
		// TODO:
		return outfile
	case *an.Struct:
		decl, imports := buf.codeForStruct(typ)
		file.add(decl, imports...)
	case *an.Enum:
		file.add(codeForEnum(typ))
	case *an.Union:
		decls, imports := buf.codeForUnion(typ)
		file.add(decls, imports...)
	default:
		panic(an.ExhaustiveTypeSwitch)
	}

	return outfile
}
