package test

import "encoding/json"

// Code generated by gomacro/generator/gounions. DO NOT EDIT

func (list ITFSlice) MarshalJSON() ([]byte, error) {
	tmp := make([]vunion2Wrapper, len(list))
	for i, v := range list {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (list *ITFSlice) UnmarshalJSON(data []byte) error {
	var tmp []vunion2Wrapper
	err := json.Unmarshal(data, &tmp)
	*list = make(ITFSlice, len(tmp))
	for i, v := range tmp {
		(*list)[i] = v.Data
	}
	return err
}

func (item StructWithITF) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Other2        string
		Member        union1Wrapper
		NoNeedWrapper ITFSlice
		Other         int
		RegularArray  []string
		RegularMap    map[int]bool
	}
	wr := wrapper{
		Other2:        item.Other2,
		Member:        union1Wrapper{item.Member},
		NoNeedWrapper: item.NoNeedWrapper,
		Other:         item.Other,
		RegularArray:  item.RegularArray,
		RegularMap:    item.RegularMap,
	}
	return json.Marshal(wr)
}

func (item *StructWithITF) UnmarshalJSON(src []byte) error {
	type wrapper struct {
		Other2        string
		Member        union1Wrapper
		NoNeedWrapper ITFSlice
		Other         int
		RegularArray  []string
		RegularMap    map[int]bool
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	item.Other2 = wr.Other2
	item.Member = wr.Member.Data
	item.NoNeedWrapper = wr.NoNeedWrapper
	item.Other = wr.Other
	item.RegularArray = wr.RegularArray
	item.RegularMap = wr.RegularMap
	return nil
}

// union1Wrapper may be used as replacements for union1
// when working with JSON
type union1Wrapper struct {
	Data union1
}

func (out *union1Wrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "member1":
		var data member1
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "member2":
		var data member2
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "member3":
		var data member3
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item union1Wrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case member1:
		wr = wrapper{Kind: "member1", Data: data}
	case member2:
		wr = wrapper{Kind: "member2", Data: data}
	case member3:
		wr = wrapper{Kind: "member3", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	member1unKind = "member1"
	member2unKind = "member2"
	member3unKind = "member3"
)

// vunion2Wrapper may be used as replacements for vunion2
// when working with JSON
type vunion2Wrapper struct {
	Data vunion2
}

func (out *vunion2Wrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "member1":
		var data member1
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item vunion2Wrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case member1:
		wr = wrapper{Kind: "member1", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	member1vuKind = "member1"
)
