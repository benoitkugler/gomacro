// Package sqlcrud generate Go functions
// to read and write from a DB defined using
// the conventions from generator/sql
package sqlcrud

import (
	"fmt"
	"go/types"
	"strings"

	an "github.com/benoitkugler/gomacro/analysis"
	"github.com/benoitkugler/gomacro/analysis/sql"
	"github.com/benoitkugler/gomacro/generator"
	gen "github.com/benoitkugler/gomacro/generator"
)

var jsonValuer = gen.Declaration{
	ID: "__json_valuer",
	Content: `
	func loadJSON(out interface{}, src interface{}) error {
		if src == nil {
			return nil //zero value out
		}
		bs, ok := src.([]byte)
		if !ok {
			return errors.New("not a []byte")
		}
		return json.Unmarshal(bs, out)
	}
	
	func dumpJSON(s interface{}) (driver.Value, error) {
		b, err := json.Marshal(s)
		if err != nil {
			return nil, err
		}
		return driver.Value(string(b)), nil
	}
	`,
}

// overriden in tests
var pqImportPath = "github.com/lib/pq"

func Generate(ana *an.Analysis) []gen.Declaration {
	header := fmt.Sprintf(`
	package %s

	// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

	import (
		"database/sql"
		"%s"
	)

	type scanner interface {
		Scan(...interface{}) error
	}
	
	// DB groups transaction like objects, and 
	// is implemented by *sql.DB and *sql.Tx
	type DB interface {
		Exec(query string, args ...interface{}) (sql.Result, error)
		Query(query string, args ...interface{}) (*sql.Rows, error)
		QueryRow(query string, args ...interface{}) *sql.Row 
		Prepare(query string) (*sql.Stmt, error)
	}
	`, ana.Root.Types.Name(), pqImportPath)

	decls := []gen.Declaration{
		{ID: "aa__header", Content: header, Priority: true},
	}

	tables := sql.SelectTables(ana)

	ctx := context{target: ana.Root.Types}
	for _, ta := range tables {
		decls = append(decls, ctx.generateTable(ta)...)
	}

	return decls
}

type context struct {
	target *types.Package
}

func (ctx context) typeName(ty types.Type) string {
	return types.TypeString(ty, generator.NameRelativeTo(ctx.target))
}

// return `true` if the column is backed by a named type belonging
// to the target package, along with its local name.
// If not, it return false, assuming that the required methods are already implemented.
func (ctx context) canImplementValuer(column sql.Column) (string, bool) {
	named, ok := column.Field.Type.Type().(*types.Named)
	if !ok {
		panic(fmt.Sprintf("field %s, written as JSON in SQL, is not named: sql.Valuer interface can't be implemented", column.Field.Field.Name()))
	}
	goTypeName := named.Obj().Name()

	return goTypeName, named.Obj().Pkg().Path() == ctx.target.Path()
}

func (ctx context) idArrayConverter(idTypeName string) gen.Declaration {
	out := gen.Declaration{
		ID: "id_array_converter_" + idTypeName,
	}
	if idTypeName == "int64" { // no copy required
		out.Content = fmt.Sprintf(`
		func %[1]sArrayToPQ(ids []%[1]s) pq.Int64Array { return ids }
		`, idTypeName)
	} else {
		out.Content = fmt.Sprintf(`
		func %[1]sArrayToPQ(ids []%[1]s) pq.Int64Array {
			out := make(pq.Int64Array, len(ids))
			for i, v := range ids {
				out[i] = int64(v)
			}
			return out
		}
		`, idTypeName)
	}

	out.Content += fmt.Sprintf(`
	// Scan%[1]sArray scans the result of a query returning a
	// list of ID's.
	func Scan%[1]sArray(rs *sql.Rows) ([]%[1]s, error) {
		defer rs.Close()
		ints := make([]%[1]s, 0, 16)
		var err error
		for rs.Next() {
			var s %[1]s
			if err = rs.Scan(&s); err != nil {
				return nil, err
			}
			ints = append(ints, s)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return ints, nil
	}
	`, idTypeName)
	return out
}

func (ctx context) generateTable(ta sql.Table) (decls []gen.Declaration) {
	if ta.Primary() >= 0 { // we have an ID
		decls = append(decls, ctx.generatePrimaryTable(ta)...)
	} else { // "link" table
		decls = append(decls, ctx.generateLinkTable(ta)...)
	}

	// generate the value interface method
	for _, col := range ta.Columns {
		if _, isTime := col.Field.Type.(*an.Time); isTime {
			goTypeName, isLocal := ctx.canImplementValuer(col)
			if isLocal {
				decls = append(decls, gen.Declaration{
					ID: "datetime_value" + goTypeName,
					Content: fmt.Sprintf(`
					func (s *%s) Scan(src interface{}) error {
						var tmp pq.NullTime
						err := tmp.Scan(src)
						if err != nil {
							return err
						}
						*s = %s(tmp.Time)
						return nil
					}
		
					func (s %s) Value() (driver.Value, error) {
						return pq.NullTime{Time: time.Time(s), Valid: true}.Value()
					}
					`, goTypeName, goTypeName, goTypeName),
				})
			}
		} else if arr, isArray := col.SQLType.(sql.Array); isArray {
			goTypeName, isLocal := ctx.canImplementValuer(col)
			if isLocal {
				var pqType string
				switch arr.A.Elem.(*an.Basic).Kind() {
				case an.BKBool:
					pqType = "pq.BoolArray"
				case an.BKInt:
					pqType = "pq.Int64Array"
				case an.BKFloat:
					pqType = "pq.Float64Array"
				case an.BKString:
					pqType = "pq.StringArray"
				}
				decls = append(decls, gen.Declaration{
					ID: "array_value" + goTypeName,
					Content: fmt.Sprintf(`
						func (s *%s) Scan(src interface{}) error  { return (*%s)(s).Scan(src) }
						func (s %s) Value() (driver.Value, error) { return %s(s).Value() }
						`, goTypeName, pqType, goTypeName, pqType),
				})
			}
		} else if _, isJSON := col.SQLType.(sql.JSON); isJSON {
			goTypeName, isLocal := ctx.canImplementValuer(col)
			if isLocal {
				decls = append(decls, gen.Declaration{
					ID: "json_value" + goTypeName,
					Content: fmt.Sprintf(`
						func (s *%s) Scan(src interface{}) error { return loadJSON(s, src) }
						func (s %s) Value() (driver.Value, error) { return dumpJSON(s) }
						`, goTypeName, goTypeName),
				}, jsonValuer)
			}
		}
	}

	return decls
}

func (ctx context) generatePrimaryTable(ta sql.Table) []gen.Declaration {
	primaryIndex := ta.Primary()
	idTypeName := ctx.typeName(ta.Columns[primaryIndex].Field.Type.Type())
	goTypeName := ta.TableName()
	sqlTableName := gen.SQLTableName(goTypeName)

	var (
		scanFields                 = make([]string, len(ta.Columns))
		columnNamesWithoutPrimary  []string // required for create/update statements
		placeholdersWithoutPrimary []string // required for create/update statements
		goFieldsWithoutPrimary     []string // required for create/update statements
	)
	for i, col := range ta.Columns {
		fieldName := col.Field.Field.Name()
		scanFields[i] = fmt.Sprintf("&item.%s,", fieldName)

		if i != primaryIndex {
			columnNamesWithoutPrimary = append(columnNamesWithoutPrimary, fieldName)
			// placeholders like $1 $2 ...
			placeholdersWithoutPrimary = append(placeholdersWithoutPrimary, fmt.Sprintf("$%d", len(placeholdersWithoutPrimary)+1))
			goFieldsWithoutPrimary = append(goFieldsWithoutPrimary, fmt.Sprintf("item.%s", fieldName))
		}
	}

	content := fmt.Sprintf(`
func scanOne%[1]s(row scanner) (%[1]s, error) {
	var item %[1]s
	err := row.Scan(
		%[4]s
	)
	return item, err
}

func Scan%[1]s(row *sql.Row) (%[1]s, error) { return scanOne%[1]s(row) }

// SelectAll returns all the items in the %[3]s table.
func SelectAll%[1]ss(db DB) (%[1]ss, error) {
	rows, err := db.Query("SELECT * FROM %[3]s")
	if err != nil {
		return nil, err
	}
	return Scan%[1]ss(rows)
}

// Select%[1]s returns the entry matching 'id'.
func Select%[1]s(tx DB, id %[2]s) (%[1]s, error) {
	row := tx.QueryRow("SELECT * FROM %[3]s WHERE id = $1", id)
	return Scan%[1]s(row)
}

// Select%[1]ss returns the entry matching the given 'ids'.
func Select%[1]ss(tx DB, ids ...%[2]s) (%[1]ss, error) {
	rows, err := tx.Query("SELECT * FROM %[3]s WHERE id = ANY($1)", %[2]sArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return Scan%[1]ss(rows)
}

type %[1]ss map[%[2]s]%[1]s

func (m %[1]ss) IDs() []%[2]s {
	out := make([]%[2]s, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func Scan%[1]ss(rs *sql.Rows) (%[1]ss, error) {
	var (
		s %[1]s
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(%[1]ss,  16)
	for rs.Next() {
		s, err = scanOne%[1]s(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one %[1]s in the database and returns the item with id filled.
func (item %[1]s) Insert(tx DB) (out %[1]s, err error) {
	row := tx.QueryRow(`+"`"+`INSERT INTO %[3]s (
		%[5]s
		) VALUES (
		%[6]s
		) RETURNING *;
		`+"`,"+`%[7]s)
	return Scan%[1]s(row)
}

// Update %[1]s in the database and returns the new version.
func (item %[1]s) Update(tx DB) (out %[1]s, err error) {
	row := tx.QueryRow(`+"`"+`UPDATE %[3]s SET (
		%[5]s
		) = (
		%[6]s
		) WHERE id = $%[8]d RETURNING *;
		`+"`,"+`%[7]s, item.%[9]s)
	return Scan%[1]s(row)
}

// Deletes the %[1]s and returns the item
func Delete%[1]sById(tx DB, id %[2]s) (%[1]s, error) {
	row := tx.QueryRow("DELETE FROM %[3]s WHERE id = $1 RETURNING *;", id)
	return Scan%[1]s(row)
}

// Deletes the %[1]s in the database and returns the ids.
func Delete%[1]ssByIDs(tx DB, ids ...%[2]s) ([]%[2]s, error) {
	rows, err := tx.Query("DELETE FROM %[3]s WHERE id = ANY($1) RETURNING id", %[2]sArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return Scan%[2]sArray(rows)
}	
`, goTypeName, idTypeName, sqlTableName,
		strings.Join(scanFields, "\n"), strings.Join(columnNamesWithoutPrimary, ", "), strings.Join(placeholdersWithoutPrimary, ", "), strings.Join(goFieldsWithoutPrimary, ", "),
		len(ta.Columns), ta.Columns[primaryIndex].Field.Field.Name(),
	)

	// generate "join like" queries
	for _, key := range ta.ForeignKeys() {
		fieldName := key.F.Field.Name()
		varName := gen.ToLowerFirst(fieldName)
		keyTypeName := "int64"

		if key.IsUnique {
			content += fmt.Sprintf(`
			// Select%[1]sBy%[2]s return zero or one item, thanks to a UNIQUE SQL constraint.
			func Select%[1]sBy%[2]s(tx DB, %[3]s %[5]s) (item %[1]s, found bool, err error) {
				row := tx.QueryRow("SELECT * FROM %[4]s WHERE %[2]s = $1", %[3]s)
				item, err = Scan%[1]s(row)
				if err == sql.ErrNoRows {
					return item, false, nil
				}
				return item, true, err
			}	
			`, goTypeName, fieldName, varName, sqlTableName, keyTypeName)
		}

		content += fmt.Sprintf(`
		func Select%[1]ssBy%[2]ss(tx DB, %[3]ss ...%[6]s) (%[1]ss, error) {
			rows, err := tx.Query("SELECT * FROM %[4]s WHERE %[2]s = ANY($1)", %[6]sArrayToPQ(%[3]ss))
			if err != nil {
				return nil, err
			}
			return Scan%[1]ss(rows)
		}	

		func Delete%[1]ssBy%[2]ss(tx DB, %[3]ss ...%[6]s) ([]%[5]s, error) {
			rows, err := tx.Query("DELETE FROM %[4]s WHERE %[2]s = ANY($1) RETURNING id", %[6]sArrayToPQ(%[3]ss))
			if err != nil {
				return nil, err
			}
			return Scan%[5]sArray(rows)
		}	
		`, goTypeName, fieldName, varName, sqlTableName, idTypeName, keyTypeName)
	}

	return []gen.Declaration{
		ctx.idArrayConverter(idTypeName),
		{
			ID:      string(goTypeName),
			Content: content,
		},
	}
}

func (ctx context) generateLinkTable(ta sql.Table) (out []gen.Declaration) {
	goTypeName := ta.TableName()
	sqlTableName := gen.SQLTableName(goTypeName)

	var (
		scanFields        = make([]string, len(ta.Columns))
		quotedColumnNames = make([]string, len(ta.Columns)) // required for insert statements

		goFields = make([]string, len(ta.Columns)) // required for create/update statements
		// placeholdersWithoutPrimary = make([]string, len(ta.Columns)) // required for create/update statements
	)
	for i, col := range ta.Columns {
		fieldName := col.Field.Field.Name()
		scanFields[i] = fmt.Sprintf("&item.%s,", fieldName)

		quotedColumnNames[i] = fmt.Sprintf("%q,", fieldName)
		goFields[i] = fmt.Sprintf("item.%s", fieldName)
		// // placeholders like $1 $2 ...
		// placeholdersWithoutPrimary[i] = fmt.Sprintf("$%d", len(placeholdersWithoutPrimary)+1)
	}

	var (
		foreignKeyFields []string
		foreignKeyComps  []string
		foreignKeyAccess []string
	)
	for i, key := range ta.ForeignKeys() {
		fieldName := key.F.Field.Name()
		foreignKeyFields = append(foreignKeyFields, fieldName)
		if key.IsNullable() { // add a guard against null values
			foreignKeyComps = append(foreignKeyComps, fmt.Sprintf("((%[1]s IS NULL AND $%[2]d IS NULL) OR %[1]s = $%[2]d)", fieldName, i+1))
		} else {
			foreignKeyComps = append(foreignKeyComps, fmt.Sprintf("%s = $%d", fieldName, i+1))
		}
		foreignKeyAccess = append(foreignKeyAccess, fmt.Sprintf("item.%s", fieldName))
	}

	content := fmt.Sprintf(`
	func scanOne%[1]s(row scanner) (%[1]s, error) {
		var item %[1]s
		err := row.Scan(
			%[3]s
		)
		return item, err
	}

	func Scan%[1]s(row *sql.Row) (%[1]s, error) { return scanOne%[1]s(row) }

	// SelectAll returns all the items in the %[2]s table.
	func SelectAll%[1]ss(db DB) (%[1]ss, error) {
		rows, err := db.Query("SELECT * FROM %[2]s")
		if err != nil {
			return nil, err
		}
		return Scan%[1]ss(rows)
	}

	type %[1]ss []%[1]s

	func Scan%[1]ss(rs *sql.Rows) (%[1]ss , error) {
		var (
			item %[1]s
			err error
		)
		defer func() {
			errClose := rs.Close()
			if err == nil {
				err = errClose
			}
		}()
		structs := make(%[1]ss , 0, 16)
		for rs.Next() {
			item, err = scanOne%[1]s(rs)
			if err != nil {
				return nil, err
			}
			structs = append(structs, item)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return structs, nil
	}

	// Insert the links %[1]s in the database.
	// It is a no-op if 'items' is empty.
	func InsertMany%[1]ss(tx *sql.Tx, items ...%[1]s) error {
		if len(items) == 0 {
			return nil
		}

		stmt, err := tx.Prepare(pq.CopyIn("%[2]s", 
			%[4]s
		))
		if err != nil {
			return err
		}

		for _, item := range items {
			_, err = stmt.Exec(%[5]s)
			if err != nil {
				return err
			}
		}

		if _, err = stmt.Exec(); err != nil {
			return err
		}
		
		if err = stmt.Close(); err != nil {
			return err
		}
		return nil
	}

	// Delete the link %[1]s from the database.
	// Only the foreign keys %[6]s fields are used in 'item'.
	func (item %[1]s) Delete(tx DB) error {
		_, err := tx.Exec(`+"`"+`DELETE FROM %[2]s WHERE %[7]s;`+
		"`,"+` %[8]s)
		return err
	}
	`, goTypeName, sqlTableName,
		strings.Join(scanFields, "\n"), strings.Join(quotedColumnNames, "\n"), strings.Join(goFields, ", "),
		strings.Join(foreignKeyFields, ", "), strings.Join(foreignKeyComps, " AND "), strings.Join(foreignKeyAccess, ", "),
	)

	// generate "join like" queries
	for _, key := range ta.ForeignKeys() {
		fieldName := key.F.Field.Name()
		varName := gen.ToLowerFirst(fieldName)
		keyTypeName := "int64"

		// lookup methods
		if !key.IsNullable() {
			keyTypeName = ctx.typeName(key.F.Field.Type())
			out = append(out, ctx.idArrayConverter(keyTypeName)) // add the converter

			if key.IsUnique {
				content += fmt.Sprintf(`
				// By%[1]s returns a map with '%[1]s' as keys.
				func (items %[2]ss) By%[1]s() map[%[3]s]%[2]s {
					out := make(map[%[3]s]%[2]s, len(items))
					for _, target := range items {
						out[target.%[1]s] = target
					}
					return out
				}`, fieldName, goTypeName, keyTypeName)
			} else {
				content += fmt.Sprintf(`
				// By%[1]s returns a map with '%[1]s' as keys.
				func (items %[2]ss) By%[1]s() map[%[3]s]%[2]ss {
					out := make(map[%[3]s]%[2]ss)
					for _, target := range items {
						out[target.%[1]s] = append(out[target.%[1]s], target)
					}
					return out
				}	
				`, fieldName, goTypeName, keyTypeName)
			}

			content += fmt.Sprintf(`
			// %[1]ss returns the list of ids of %[1]s
			// contained in this link table.
			// They are not garanteed to be distinct.
			func (items %[2]ss) %[1]ss() []%[3]s {
				out := make([]%[3]s, len(items))
				for index, target := range items {
					out[index] = target.%[1]s
				}
				return out
			}
			`, fieldName, goTypeName, keyTypeName)
		}

		if key.IsUnique {
			content += fmt.Sprintf(`
			// Select%[1]sBy%[2]s return zero or one item, thanks to a UNIQUE SQL constraint.
			func Select%[1]sBy%[2]s(tx DB, %[3]s %[5]s) (item %[1]s, found bool, err error) {
				row := tx.QueryRow("SELECT * FROM %[4]s WHERE %[2]s = $1", %[3]s)
				item, err = Scan%[1]s(row)
				if err == sql.ErrNoRows {
					return item, false, nil
				}
				return item, true, err
			}
			`, goTypeName, fieldName, varName, sqlTableName, keyTypeName)
		}

		content += fmt.Sprintf(`
		func Select%[1]ssBy%[2]ss(tx DB, %[3]ss ...%[5]s) (%[1]ss, error) {
			rows, err := tx.Query("SELECT * FROM %[4]s WHERE %[2]s = ANY($1)", %[5]sArrayToPQ(%[3]ss))
			if err != nil {
				return nil, err
			}
			return Scan%[1]ss(rows)
		}

		func Delete%[1]ssBy%[2]ss(tx DB, %[3]ss ...%[5]s) (%[1]ss, error)  {
			rows, err := tx.Query("DELETE FROM %[4]s WHERE %[2]s = ANY($1) RETURNING *", %[5]sArrayToPQ(%[3]ss))
			if err != nil {
				return nil, err
			}
			return Scan%[1]ss(rows)
		}	
		`, goTypeName, fieldName, varName, sqlTableName, keyTypeName)
	}

	return append(out, gen.Declaration{
		ID:      string(goTypeName),
		Content: content,
	})
}
